name: Build tt-xla

# Implements artifact caching to avoid unnecessary rebuilds.
# Artifacts are reused only when: not a PR, no mlir_override, and exact name match exists.
# Naming: "xla-whl-{release|codecov}[-commit_sha]" (SHA added for individual commits only).

on:
  workflow_call:
    inputs:
        mlir_override:
            description: 'Git SHA of commit in tenstorrent/tt-mlir'
            required: false
            type: string
        docker_image:
            description: 'Docker image to use for the build'
            required: true
            type: string
        build_type:
            description: 'Build type for the wheel: release, codecov, debug, explorer'
            default: release
            type: string
            required: false
    outputs:
        wheel_artifact_name:
            description: 'Name of the wheel artifact'
            value: ${{ jobs.check-existing-artifact.outputs.wheel_artifact_name }}
        wheel_release_vllm_tt_artifact_name:
            description: 'Name of the vllm-tt plugin wheel artifact'
            value: ${{ jobs.check-existing-artifact.outputs.wheel_release_vllm_tt_artifact_name }}
        build_artifact_name:
            description: 'Name of the build artifact'
            value: ${{ jobs.check-existing-artifact.outputs.build_artifact_name }}
        artifacts_run_id:
            description: 'Run ID of the artifacts'
            value: ${{ jobs.check-existing-artifact.outputs.artifacts_run_id || github.run_id }}

jobs:
  check-existing-artifact:
    runs-on: ubuntu-latest
    name: "Check for existing artifact"
    outputs:
      artifacts_run_id: ${{ steps.check-artifact.outputs.artifacts_run_id }}
      wheel_artifact_name: ${{ steps.generate-name.outputs.wheel_artifact_name }}
      wheel_release_vllm_tt_artifact_name: ${{ steps.generate-name.outputs.wheel_release_vllm_tt_artifact_name }}
      build_artifact_name: ${{ steps.generate-name.outputs.build_artifact_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate artifact name
        id: generate-name
        shell: bash
        run: |
          build_name=${{ inputs.build_type }}

          # Add commit SHA to artifact name only when all conditions are met:
          # - Not a pull request event
          # - Not a merge commit (has exactly 1 parent)
          # - No MLIR override specified
          if [[ "${{ github.event_name }}" != "pull_request" && \
                $(git cat-file -p HEAD | grep -c "^parent ") -eq 1 && \
                "${{ inputs.mlir_override }}" == "" ]]; then
            artifact_suffix="-$(git rev-parse --short HEAD)"
            echo "reusable_artifact=true" >> "$GITHUB_OUTPUT"
          else
            artifact_suffix=""
            echo "reusable_artifact=false" >> "$GITHUB_OUTPUT"
          fi
          wheel_artifact_name="xla-whl-${build_name}${artifact_suffix}"
          wheel_release_vllm_tt_artifact_name="vllm-tt-whl-${build_name}${artifact_suffix}"
          build_artifact_name="build-artifacts${artifact_suffix}"
          echo "wheel_artifact_name=${wheel_artifact_name}" >> "$GITHUB_OUTPUT"
          echo "wheel_release_vllm_tt_artifact_name=${wheel_release_vllm_tt_artifact_name}" >> "$GITHUB_OUTPUT"
          echo "build_artifact_name=${build_artifact_name}" >> "$GITHUB_OUTPUT"
          echo "Generated artifact name: $wheel_artifact_name"

      - name: Check if artifact exists
        if: ${{ steps.generate-name.outputs.reusable_artifact == 'true' }}
        id: check-artifact
        shell: bash
        run: |
          # Use GitHub API to check for existing artifacts
          response=$(curl -s -H "Authorization: token ${{ github.token }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts?name=${{ steps.generate-name.outputs.wheel_artifact_name }}")
          total_count=$(echo "$response" | jq -r '.total_count')

          if [ "$total_count" -gt 0 ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            # Get the download URL of the most recent artifact
            download_url=$(echo "$response" | jq -r '.artifacts[0].archive_download_url')
            artifacts_run_id=$(echo "$response" | jq -r '.artifacts[0].workflow_run.id')
            echo "url=${download_url}" >> "$GITHUB_OUTPUT"
            echo "artifacts_run_id=${artifacts_run_id}" >> "$GITHUB_OUTPUT"
            echo "Found existing artifact: ${{ steps.generate-name.outputs.wheel_artifact_name }}"
            echo "Artifact URL: $download_url"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "url=" >> "$GITHUB_OUTPUT"
            echo "artifacts_run_id=" >> "$GITHUB_OUTPUT"
            echo "No existing artifact found for: ${{ steps.generate-name.outputs.wheel_artifact_name }}"
          fi

  build-ttxla:
    needs: check-existing-artifact
    if: ${{ !needs.check-existing-artifact.outputs.artifacts_run_id }}
    timeout-minutes: 120
    runs-on: tt-ubuntu-2204-large-stable
    name: "Build tt-xla"
    container:
      image: ${{ inputs.docker_image }}

    steps:
      - name: Mark repo as safe for git
        run: |
            echo "Current user: $(whoami)"
            ls -ld $(pwd)
            git config --global --add safe.directory /__w/tt-xla/tt-xla
            git config --global --add safe.directory /__w/tt-xla/tt-xla/third_party/tt_forge_models

      - uses: actions/checkout@v4
        with:
            submodules: recursive
            repository: 'tenstorrent/tt-xla'

      - name: Override tt-mlir SHA mlir_override is set
        if: ${{ inputs.mlir_override }}
        shell: bash
        run: |
            # Update the CMakeLists.txt file with the new SHA
            sed -i "s/set(TT_MLIR_VERSION \".*\")/set(TT_MLIR_VERSION \"${{ inputs.mlir_override }}\")/" third_party/CMakeLists.txt

      - name: Set reusable strings
        id: strings
        shell: bash
        run: |
            echo "work-dir=$(pwd)" >> "$GITHUB_OUTPUT"
            echo "build-output-dir=$(pwd)/build" >> "$GITHUB_OUTPUT"
            echo "build-name=${{ inputs.build_type }}" >> "$GITHUB_OUTPUT"

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
            create-symlink: true
            key: "${{ steps.strings.outputs.build-name }}-build"

      - name: Build the wheel
        shell: bash
        run: |
            source venv/activate
            cd ${{ steps.strings.outputs.work-dir }}/python_package
            python setup.py bdist_wheel --build-type ${{ inputs.build_type }}

      - name: convert the wheel to manylinux wheel
        shell: bash
        run: |
            source venv/activate
            cd ${{ steps.strings.outputs.work-dir }}/python_package
            apt-get install -y patchelf zip
            pip install auditwheel

            # Exclude tt-metal libs to prevent auditwheel from creating duplicates.
            # Without --exclude, auditwheel bundles copies from CI build paths into .libs/,
            # causing protobuf symbol conflicts at runtime ("CHECK failed: file != nullptr").
            # See: https://github.com/tenstorrent/tt-xla/pull/2426#issuecomment-3629829349
            auditwheel repair \
              --exclude libtt_metal.so \
              --exclude libdevice.so \
              --exclude libtracy.so \
              --exclude libtt_stl.so \
              --exclude _ttnncpp.so \
              --plat manylinux_2_35_x86_64 dist/pjrt_plugin_tt*.whl -w wheelhouse/

            # Fix duplicate Root-Is-Purelib entries created by auditwheel.
            # Upstream issue: https://github.com/pypa/auditwheel/issues/642
            # Details: https://github.com/tenstorrent/tt-xla/pull/2426#issuecomment-3629829349
            cd wheelhouse
            whl=$(ls pjrt_plugin_tt*.whl)
            echo "Fixing WHEEL metadata in $whl"
            tmpdir=$(mktemp -d)
            unzip -q "$whl" -d "$tmpdir"

            # Find and fix the WHEEL file - replace Root-Is-Purelib value and remove duplicates
            wheel_file=$(find "$tmpdir" -name "WHEEL" -path "*dist-info*")
            echo "Original WHEEL file:"
            cat "$wheel_file"
            # Replace first Root-Is-Purelib with correct value, remove any duplicates
            awk '/Root-Is-Purelib/ { if (!seen) { print "Root-Is-Purelib: false"; seen=1 } next } { print }' "$wheel_file" > "${wheel_file}.tmp"
            mv "${wheel_file}.tmp" "$wheel_file"
            echo "Fixed WHEEL file contents:"
            cat "$wheel_file"

            # Repack the wheel using absolute path
            whl_abs="$(pwd)/$whl"
            rm "$whl"
            cd "$tmpdir"
            zip -rq "$whl_abs" .
            cd -
            rm -rf "$tmpdir"
            cd ..

            # Delete the original wheel in favor of the manylinux wheel in wheelhouse directory
            rm -rf ${{ steps.strings.outputs.work-dir }}/python_package/dist/*.whl

      - name: Validate build type of wheel build
        shell: bash
        run: |
            source venv/activate
            cd ${{ steps.strings.outputs.work-dir }}/python_package/wheelhouse
            #Inspect the wheel build type on wheel file without installing the wheel
            pip install wheel-inspect
            wheel_summary=$(wheel2json pjrt_plugin_tt*.whl | jq -r '.dist_info.metadata.summary')
            match=$(echo "$wheel_summary" | grep -oP "build-type=${{ inputs.build_type }}" || true)
            echo "Wheel summary: $wheel_summary"
            if [ -z "$match" ]; then
                echo "Wheel summary does not match build type: ${{ inputs.build_type }}"
                exit 1
            fi

      - name: Upload the wheel
        id: upload-wheel
        uses: actions/upload-artifact@v4
        with:
            name: ${{ needs.check-existing-artifact.outputs.wheel_artifact_name }}
            path: ${{ steps.strings.outputs.work-dir }}/python_package/wheelhouse/*.whl

      - name: Build vllm plugin wheel
        if: inputs.build_type == 'release'
        shell: bash
        run: |
            source venv/activate
            cd ${{ steps.strings.outputs.work-dir }}/integrations/vllm_plugin
            python setup.py bdist_wheel $(if [ '${{ inputs.debug_build }}' == 'true' ]; then echo '--code-coverage'; fi)

      - name: Upload the vllm plugin wheel
        if: inputs.build_type == 'release'
        id: upload-vllm-tt-wheel
        uses: actions/upload-artifact@v4
        with:
            name: ${{ needs.check-existing-artifact.outputs.wheel_release_vllm_tt_artifact_name }}
            path: ${{ steps.strings.outputs.work-dir }}/integrations/vllm_plugin/dist/vllm_tt*.whl

      - name: Archive Build Directory
        if: inputs.build_type == 'codecov'
        shell: bash
        working-directory: ${{ steps.strings.outputs.build-output-dir }}
        run: tar cf artifact.tar .

      - name: Upload Build Folder
        if: inputs.build_type == 'codecov'
        uses: actions/upload-artifact@v4
        with:
            name: ${{ needs.check-existing-artifact.outputs.build_artifact_name }}
            path: ${{ steps.strings.outputs.build-output-dir }}/artifact.tar

      - name: Remove tar archive
        if: inputs.build_type == 'codecov'
        shell: bash
        run: rm -f ${{ steps.strings.outputs.build-output-dir }}/artifact.tar
